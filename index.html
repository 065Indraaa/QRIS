<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QRIS ↔ QR Morph • Smooth & Modern</title>
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #ffffff; /* putih kontras */
      display: grid;
      place-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .wrap { width: min(88vmin, 560px); aspect-ratio: 1/1; position: relative; }
    canvas { width: 100%; height: 100%; display: block; }
    .badge {
      position: absolute; inset: auto 0 8px 0;
      text-align: center; font-size: 12px; color: #1119;
      user-select: none; pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="morph"></canvas>
    <div class="badge">QRIS ↔ QR • smooth morph (loop)</div>
  </div>

<script>
(function(){
  // === PARAMETER ===
  const CANVAS_SIZE = 700;
  const SAMPLE_STEP = 2;
  const DOT_SIZE = 3.5;       // agak lebih besar biar solid
  const HOLD_TIME = 900;
  const MORPH_TIME = 2000;
  const BREATH_AMPL = 0.02;

  const canvas = document.getElementById('morph');
  const ctx = canvas.getContext('2d');
  canvas.width = CANVAS_SIZE; canvas.height = CANVAS_SIZE;

  // Muat gambar: logo & QR
  const imgLogo = new Image(); imgLogo.src = 'log.png';
  const imgQR   = new Image(); imgQR.src   = 'QR.png';

  Promise.all([
    new Promise(res => imgLogo.onload = res),
    new Promise(res => imgQR.onload   = res)
  ]).then(init).catch(err => {
    console.error(err);
    ctx.fillStyle = '#000';
    ctx.font = '16px system-ui';
    ctx.fillText('Gagal memuat gambar log.png / QR.png', 16, 24);
  });

  function fitContainRect(w, h, box){
    const r = Math.min(box / w, box / h);
    const nw = w * r, nh = h * r;
    return { w: nw, h: nh, x: (box - nw)/2, y: (box - nh)/2 };
  }

  function sampleImageToPoints(img){
    const off = document.createElement('canvas');
    off.width = CANVAS_SIZE; off.height = CANVAS_SIZE;
    const octx = off.getContext('2d');

    const rect = fitContainRect(img.width, img.height, CANVAS_SIZE*0.78);
    octx.clearRect(0,0,off.width,off.height);
    octx.drawImage(img, rect.x + (CANVAS_SIZE*0.11), rect.y + (CANVAS_SIZE*0.11), rect.w, rect.h);

    const data = octx.getImageData(0,0,off.width,off.height).data;
    const points = [];
    for(let y=0; y<off.height; y+=SAMPLE_STEP){
      for(let x=0; x<off.width; x+=SAMPLE_STEP){
        const idx = (y*off.width + x)*4;
        const r=data[idx], g=data[idx+1], b=data[idx+2], a=data[idx+3];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if(a>40 && lum<220){ // threshold lebih keras
          points.push({x, y});
        }
      }
    }
    return points;
  }

  function sortCyclic(points){
    const cx = CANVAS_SIZE/2, cy = CANVAS_SIZE/2;
    return points.slice().sort((p,q)=> Math.atan2(p.y-cy, p.x-cx) - Math.atan2(q.y-cy, q.x-cx));
  }

  function equalizeCount(a,b){
    const outA = a.slice(), outB = b.slice();
    while(outA.length < outB.length){ outA.push(outA[Math.floor(Math.random()*outA.length)]); }
    while(outB.length < outA.length){ outB.push(outB[Math.floor(Math.random()*outB.length)]); }
    return [outA, outB];
  }

  // Easing cubic easeInOut
  function easeInOutCubic(t){
    return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
  }

  // Noise fungsi untuk variasi gerak titik
  function noise(t){
    return (Math.sin(t*12) + Math.sin(t*7.3 + 1.5) + Math.sin(t*4.7 + 3.7)) * 0.5;
  }

  let srcSorted, dstSorted, particles = [];

  function init(){
    const ptsLogo = sampleImageToPoints(imgLogo);
    const ptsQR   = sampleImageToPoints(imgQR);

    srcSorted = sortCyclic(ptsLogo);
    dstSorted = sortCyclic(ptsQR);
    [srcSorted, dstSorted] = equalizeCount(srcSorted, dstSorted);

    particles = srcSorted.map((p,i)=>({ x:p.x, y:p.y, sx:p.x, sy:p.y, tx:dstSorted[i].x, ty:dstSorted[i].y }));

    state = 'HOLD_SRC'; time0 = performance.now();
    requestAnimationFrame(tick);
  }

  let state = 'HOLD_SRC';
  let time0 = 0;

  function setTargets(dir){
    if(dir===1){ // logo → QR
      for(let i=0;i<particles.length;i++){
        particles[i].sx = particles[i].x; particles[i].sy = particles[i].y;
        particles[i].tx = dstSorted[i].x; particles[i].ty = dstSorted[i].y;
      }
    }else{ // QR → logo
      for(let i=0;i<particles.length;i++){
        particles[i].sx = particles[i].x; particles[i].sy = particles[i].y;
        particles[i].tx = srcSorted[i].x; particles[i].ty = srcSorted[i].y;
      }
    }
  }

  function render(progress, breathing=0, now=0){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();

    const cx = CANVAS_SIZE/2, cy = CANVAS_SIZE/2;
    ctx.translate(cx, cy);

    // Scale halus dan dinamis, pake breathing + sin untuk feel natural
    let scaleBase = 1 + breathing * 0.08 * Math.sin(now*0.005);
    ctx.scale(scaleBase, scaleBase);

    ctx.translate(-cx, -cy);

    for(let i=0; i<particles.length; i++){
      const p = particles[i];

      // Morph progress dengan easing cubic
      const easedProgress = easeInOutCubic(progress);

      // Hitung posisi interpolasi + noise
      let x = p.sx + (p.tx - p.sx) * easedProgress;
      let y = p.sy + (p.ty - p.sy) * easedProgress;

      // Noise kecil per titik agar tidak monoton
      const timeFactor = now*0.002 + i*0.1;
      x += noise(timeFactor) * 1.2;
      y += noise(timeFactor + 100) * 1.2;

      // Opacity dinamis supaya titik lebih hidup
      const opacity = 0.3 + 0.7 * (1 - Math.abs(0.5 - easedProgress)*2);

      // Grayscale dengan opacity berubah-ubah
      const grayLevel = 30 + 120 * (1 - easedProgress);
      ctx.fillStyle = `rgba(${grayLevel},${grayLevel},${grayLevel},${opacity.toFixed(2)})`;

      // Ukuran titik mengikuti progress & noise agar dinamis
      const size = DOT_SIZE * (0.7 + 0.6 * Math.sin(timeFactor*3 + easedProgress * Math.PI * 4));

      ctx.beginPath();
      ctx.ellipse(x, y, size/2, size/2, 0, 0, 2*Math.PI);
      ctx.fill();
    }

    ctx.restore();
  }

  function tick(now){
    const dt = now - time0;

    if(state==='HOLD_SRC'){
      render(0, Math.sin(now*0.004)*BREATH_AMPL, now);
      if(dt>=HOLD_TIME){ state='MORPH_FWD'; time0=now; setTargets(1); }
    }
    else if(state==='MORPH_FWD'){
      const t = Math.min(1, dt / MORPH_TIME);
      render(t, 0, now);
      if(t>=1){ state='HOLD_DST'; time0=now; }
    }
    else if(state==='HOLD_DST'){
      render(1, Math.sin(now*0.004)*BREATH_AMPL, now);
      if(dt>=HOLD_TIME){ state='MORPH_BWD'; time0=now; setTargets(-1); }
    }
    else if(state==='MORPH_BWD'){
      const t = Math.min(1, dt / MORPH_TIME);
      render(1 - t, 0, now);
      if(t>=1){ state='HOLD_SRC'; time0=now; }
    }
    requestAnimationFrame(tick);
  }
})();
</script>
</body>
</html>
