<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QRIS (Quick Response Code Indonesian Standard)</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%;
    background: #fff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    color: #222;
    padding: 40px 60px;
    background-image:
      linear-gradient(0deg, rgba(0,0,0,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  .page-wrapper {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: flex-start;
    gap: 60px;
    max-width: 1400px;
    width: 100%;
    margin: 0 auto;
  }

  .container {
    flex: 1;
    max-width: 700px;
    aspect-ratio: 1 / 1;
    position: relative;
    user-select: none;
    border-radius: 16px;
    background: linear-gradient(145deg, #f8f9fa, #e9ecef);
    box-shadow:
      0 10px 20px rgba(0,0,0,0.1),
      inset 0 0 30px #fff;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 16px;
  }
  .badge {
    position: absolute;
    bottom: 10px; left: 0; right: 0;
    text-align: center;
    font-size: 14px;
    font-weight: 600;
    color: #444;
    user-select: none;
  }

  .explanation {
    flex: 1;
    max-width: 640px;
    font-size: 16px;
    line-height: 1.6;
    color: #444;
    background: #fefefe;
    border-radius: 12px;
    padding: 20px 28px;
    box-shadow: 0 4px 16px rgb(0 0 0 / 0.07);
  }
  .explanation h2 {
    margin-top: 0;
    font-weight: 700;
    color: #111;
  }
/* Header styling */
.site-header {
  text-align: center;
  margin-bottom: 40px;
  padding-bottom: 20px;
  border-bottom: 1px solid #ddd;
}
.site-header h1 {
  margin: 0;
  font-size: 28px;
  color: #111;
}
.site-header p {
  margin: 4px 0 0;
  font-size: 16px;
  color: #555;
}

/* Footer styling */
.site-footer {
  text-align: center;
  margin-top: 60px;
  padding-top: 20px;
  font-size: 14px;
  color: #777;
  border-top: 1px solid #ddd;
}
  @media (max-width: 1024px) {
    .page-wrapper {
      flex-direction: column;
      align-items: center;
      gap: 40px;
    }
    .container, .explanation {
      max-width: 90vw;
      flex: none;
    }
  }

  @media (max-width: 600px) {
    body {
      padding: 20px;
    }
    .explanation {
      font-size: 14px;
      padding: 16px 20px;
    }
  }
</style>
</head>
  <header class="site-header">
  <h1>(Quick Response Code Indonesian Standard)</h1>
  <p>Unifying Payments with a Single Code</p>
</header>
<body>

<div class="page-wrapper">
  <div class="container">
    <canvas id="morph"></canvas>
    <div class="badge">QRIS (Quick Response Code Indonesian Standard)</div>
  </div>

  <div class="explanation" aria-label="Detailed explanation of QRIS">
    <h2>About QRIS (Quick Response Code Indonesian Standard)</h2>
    <p>
      QRIS is Indonesia's standardized quick response code system designed to unify the digital payment ecosystem. It enables various payment services to interoperate seamlessly, allowing consumers to make payments using different providers by scanning a single QR code.
    </p>
    <p>
      Developed by <a href="https://www.bi.go.id/en/fungsi-utama/sistem-pembayaran/ritel/kanal-layanan/qris/default.aspx" target="_blank" rel="noopener">Bank Indonesia</a> in collaboration with the Indonesian Payment System Association (ASPI), QRIS aims to simplify payment acceptance for merchants, increase transaction efficiency, and promote financial inclusion across the country. It supports payments via e-wallets, mobile banking, and other digital platforms under one standardized system.
    </p>
    <p>The QRIS initiative, promoting financial inclusion in Indonesia, has caught the attention of the United States, which labeled it a trade barrier. Curious to learn why?  
  <a href="https://windonesia.com/article/us-cites-qris-as-trade-barrier-but-us-payment-model-unfit-for-indonesia" target="_blank" rel="noopener" style="color: #007acc; text-decoration: none;">Read the full article here</a>.</p>
  </div>
</div>
<footer class="site-footer">
  <p>&copy; 2025 QRIS Indonesia â€¢ Powered by Bank Indonesia & ASPI</p>
</footer>
<script>
(() => {
  const CANVAS_SIZE = 500;
  const SAMPLE_STEP = 3;  // Lebih besar = lebih ringan tapi titik lebih jarang
  const DOT_SIZE = 2;
  const HOLD_TIME = 1000;
  const MORPH_TIME = 2500;
  const BACKGROUND_COLOR = '#f8f9fa';

  const canvas = document.getElementById('morph');
  const ctx = canvas.getContext('2d');
  canvas.width = CANVAS_SIZE;
  canvas.height = CANVAS_SIZE;

  const imgLogo = new Image();
  imgLogo.crossOrigin = 'anonymous';
  imgLogo.src = 'log.png'; // Ganti dengan path logo
  const imgQR = new Image();
  imgQR.crossOrigin = 'anonymous';
  imgQR.src = 'QR.png';    // Ganti dengan path QR

  function fitContainRect(w, h, box) {
    const ratio = Math.min(box / w, box / h);
    const nw = w * ratio;
    const nh = h * ratio;
    return {
      w: nw,
      h: nh,
      x: (CANVAS_SIZE - nw) / 2,
      y: (CANVAS_SIZE - nh) / 2
    };
  }

  function sampleImageToPoints(img) {
    const off = document.createElement('canvas');
    off.width = CANVAS_SIZE;
    off.height = CANVAS_SIZE;
    const octx = off.getContext('2d');

    const rect = fitContainRect(img.width, img.height, CANVAS_SIZE * 0.8);
    octx.clearRect(0, 0, off.width, off.height);
    octx.drawImage(img, rect.x, rect.y, rect.w, rect.h);

    const data = octx.getImageData(0, 0, off.width, off.height).data;
    const points = [];

    for (let y = 0; y < off.height; y += SAMPLE_STEP) {
      for (let x = 0; x < off.width; x += SAMPLE_STEP) {
        const idx = (y * off.width + x) * 4;
        const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if (a > 50 && lum < 180) { // titik gelap di image
          points.push({x, y});
        }
      }
    }
    return points;
  }

  function sortCyclic(points) {
    const cx = CANVAS_SIZE/2, cy = CANVAS_SIZE/2;
    return points.slice().sort((p, q) => {
      return Math.atan2(p.y-cy, p.x-cx) - Math.atan2(q.y-cy, q.x-cx);
    });
  }

  function equalizeCount(a, b) {
    const outA = a.slice();
    const outB = b.slice();
    while (outA.length < outB.length) outA.push(outA[Math.floor(Math.random()*outA.length)]);
    while (outB.length < outA.length) outB.push(outB[Math.floor(Math.random()*outB.length)]);
    return [outA, outB];
  }

  function smoothStep(t) {
    return t*t*(3-2*t);
  }

  let particles = [];
  let srcPoints, dstPoints;
  let morphProgress = 0;
  let morphDirection = 1;
  let morphStartTime = 0;
  let currentPhase = 'holdStart';

  Promise.all([
    new Promise(res => imgLogo.onload = res),
    new Promise(res => imgQR.onload = res)
  ]).then(() => {
    srcPoints = sortCyclic(sampleImageToPoints(imgLogo));
    dstPoints = sortCyclic(sampleImageToPoints(imgQR));
    [srcPoints, dstPoints] = equalizeCount(srcPoints, dstPoints);

    particles = srcPoints.map((p,i) => ({
      x: p.x, y: p.y,
      sx: p.x, sy: p.y,
      tx: dstPoints[i].x, ty: dstPoints[i].y
    }));

    morphStartTime = performance.now();
    requestAnimationFrame(animate);
  }).catch(() => {
    ctx.fillStyle = '#222';
    ctx.font = '16px sans-serif';
    ctx.fillText('Failed to load images', 10, 30);
  });

  function animate(now) {
    const elapsed = now - morphStartTime;

    if (currentPhase === 'holdStart') {
      morphProgress = 0;
      if (elapsed >= HOLD_TIME) {
        currentPhase = 'morphing';
        morphStartTime = now;
        morphDirection = 1;
      }
    } else if (currentPhase === 'morphing') {
      let t = elapsed / MORPH_TIME;
      if (t > 1) {
        t = 1;
        currentPhase = 'holdEnd';
        morphStartTime = now;
      }
      morphProgress = morphDirection === 1 ? smoothStep(t) : smoothStep(1 - t);
    } else if (currentPhase === 'holdEnd') {
      morphProgress = morphDirection === 1 ? 1 : 0;
      if (elapsed >= HOLD_TIME) {
        morphDirection *= -1;
        currentPhase = 'morphing';
        morphStartTime = now;
      }
    }

    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.fillStyle = BACKGROUND_COLOR;
    ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

    for (const p of particles) {
      const ix = p.sx + (p.tx - p.sx) * morphProgress;
      const iy = p.sy + (p.ty - p.sy) * morphProgress;

      ctx.fillStyle = '#000';
      ctx.fillRect(
        Math.round(ix - DOT_SIZE / 2),
        Math.round(iy - DOT_SIZE / 2),
        DOT_SIZE,
        DOT_SIZE
      );
    }

    requestAnimationFrame(animate);
  }
})();
</script>

</body>
</html>

