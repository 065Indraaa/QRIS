<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QRIS ↔ QR Morph • Smooth & Modern White Theme</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #fff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    color: #222;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .container {
    max-width: 700px;
    width: 90vw;
    aspect-ratio: 1 / 1;
    position: relative;
    user-select: none;
    border-radius: 16px;
    background: linear-gradient(145deg, #f8f9fa, #e9ecef);
    box-shadow:
      0 10px 20px rgba(0,0,0,0.1),
      inset 0 0 30px #fff;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 16px;
  }
  .badge {
    position: absolute;
    bottom: 10px; left: 0; right: 0;
    text-align: center;
    font-size: 14px;
    font-weight: 600;
    color: #444;
    user-select: none;
  }
  .explanation {
    margin-top: 28px;
    max-width: 700px;
    width: 90vw;
    font-size: 16px;
    line-height: 1.6;
    color: #444;
    background: #fefefe;
    border-radius: 12px;
    padding: 20px 28px;
    box-shadow: 0 4px 16px rgb(0 0 0 / 0.07);
  }
  .explanation h2 {
    margin-top: 0;
    font-weight: 700;
    color: #111;
  }
  @media (max-width: 600px) {
    .explanation {
      font-size: 14px;
      padding: 16px 20px;
    }
  }
</style>
</head>
<body>

<div class="container">
  <canvas id="morph"></canvas>
  <div class="badge">QRIS ↔ QR • Smooth Morphing Animation Loop</div>
</div>

<div class="explanation" aria-label="Detailed explanation of QRIS">
  <h2>About QRIS (Quick Response Code Indonesian Standard)</h2>
  <p>
    QRIS is Indonesia's standardized quick response code system designed to unify the digital payment ecosystem. It enables various payment services to interoperate seamlessly, allowing consumers to make payments using different providers by scanning a single QR code.
  </p>
  <p>
    Developed by Bank Indonesia in collaboration with the Indonesian Payment System Association (ASPI), QRIS aims to simplify payment acceptance for merchants, increase transaction efficiency, and promote financial inclusion across the country. It supports payments via e-wallets, mobile banking, and other digital platforms under one standardized system.
  </p>
  <p>
    This morphing animation illustrates the transformation between the QRIS logo and a typical QR code, symbolizing the bridging of brand identity and technical utility in a visually appealing and modern manner.
  </p>
</div>

<script>
(() => {
  const CANVAS_SIZE = 700;
  const SAMPLE_STEP = 3;
  const DOT_SIZE = 4;
  const HOLD_TIME = 1000;
  const MORPH_TIME = 2500;
  const JITTER_AMPLITUDE = 1.2;
  const SCALE_AMPLITUDE = 0.15;
  const BACKGROUND_COLOR = '#f8f9fa';

  const canvas = document.getElementById('morph');
  const ctx = canvas.getContext('2d');
  canvas.width = CANVAS_SIZE;
  canvas.height = CANVAS_SIZE;

  const imgLogo = new Image();
  imgLogo.crossOrigin = 'anonymous';
  imgLogo.src = 'log.png'; // Ganti dengan path logo
  const imgQR = new Image();
  imgQR.crossOrigin = 'anonymous';
  imgQR.src = 'QR.png';    // Ganti dengan path QR

  function fitContainRect(w, h, box) {
    const ratio = Math.min(box / w, box / h);
    const nw = w * ratio;
    const nh = h * ratio;
    return {
      w: nw,
      h: nh,
      x: (CANVAS_SIZE - nw) / 2,
      y: (CANVAS_SIZE - nh) / 2
    };
  }

  function sampleImageToPoints(img) {
    const off = document.createElement('canvas');
    off.width = CANVAS_SIZE;
    off.height = CANVAS_SIZE;
    const octx = off.getContext('2d');

    const rect = fitContainRect(img.width, img.height, CANVAS_SIZE * 0.8);
    octx.clearRect(0, 0, off.width, off.height);
    octx.drawImage(img, rect.x, rect.y, rect.w, rect.h);

    const data = octx.getImageData(0, 0, off.width, off.height).data;
    const points = [];

    for (let y = 0; y < off.height; y += SAMPLE_STEP) {
      for (let x = 0; x < off.width; x += SAMPLE_STEP) {
        const idx = (y * off.width + x) * 4;
        const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if (a > 50 && lum < 180) { // titik gelap di image
          points.push({x, y});
        }
      }
    }
    return points;
  }

  function sortCyclic(points) {
    const cx = CANVAS_SIZE/2, cy = CANVAS_SIZE/2;
    return points.slice().sort((p, q) => {
      return Math.atan2(p.y-cy, p.x-cx) - Math.atan2(q.y-cy, q.x-cx);
    });
  }

  function equalizeCount(a, b) {
    const outA = a.slice();
    const outB = b.slice();
    while (outA.length < outB.length) outA.push(outA[Math.floor(Math.random()*outA.length)]);
    while (outB.length < outA.length) outB.push(outB[Math.floor(Math.random()*outB.length)]);
    return [outA, outB];
  }

  function smoothStep(t) {
    return t*t*(3-2*t);
  }

  let particles = [];
  let srcPoints, dstPoints;
  let morphProgress = 0;
  let morphDirection = 1;
  let morphStartTime = 0;
  let currentPhase = 'holdStart';

  Promise.all([
    new Promise(res => imgLogo.onload = res),
    new Promise(res => imgQR.onload = res)
  ]).then(() => {
    srcPoints = sortCyclic(sampleImageToPoints(imgLogo));
    dstPoints = sortCyclic(sampleImageToPoints(imgQR));
    [srcPoints, dstPoints] = equalizeCount(srcPoints, dstPoints);

    particles = srcPoints.map((p,i) => ({
      x: p.x, y: p.y,
      sx: p.x, sy: p.y,
      tx: dstPoints[i].x, ty: dstPoints[i].y,
      jitterX: 0, jitterY: 0,
      scale: 1
    }));

    morphStartTime = performance.now();
    requestAnimationFrame(animate);
  }).catch(() => {
    ctx.fillStyle = '#222';
    ctx.font = '16px sans-serif';
    ctx.fillText('Failed to load images', 10, 30);
  });

  function animate(now) {
    const elapsed = now - morphStartTime;

    if (currentPhase === 'holdStart') {
      morphProgress = 0;
      if (elapsed >= HOLD_TIME) {
        currentPhase = 'morphing';
        morphStartTime = now;
        morphDirection = 1;
      }
    } else if (currentPhase === 'morphing') {
      let t = elapsed / MORPH_TIME;
      if (t > 1) {
        t = 1;
        currentPhase = 'holdEnd';
        morphStartTime = now;
      }
      morphProgress = morphDirection === 1 ? smoothStep(t) : smoothStep(1 - t);
    } else if (currentPhase === 'holdEnd') {
      morphProgress = morphDirection === 1 ? 1 : 0;
      if (elapsed >= HOLD_TIME) {
        morphDirection *= -1;
        currentPhase = 'morphing';
        morphStartTime = now;
      }
    }

    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.fillStyle = BACKGROUND_COLOR;
    ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

    for (const p of particles) {
      const ix = p.sx + (p.tx - p.sx) * morphProgress;
      const iy = p.sy + (p.ty - p.sy) * morphProgress;

      p.jitterX = Math.sin(now*0.004 + ix*0.08)*JITTER_AMPLITUDE;
      p.jitterY = Math.cos(now*0.004 + iy*0.08)*JITTER_AMPLITUDE;
      const pulse = 1 + Math.sin(now*0.006 + ix*0.06)*SCALE_AMPLITUDE;

      ctx.beginPath();
      ctx.arc(ix + p.jitterX, iy + p.jitterY, DOT_SIZE * pulse, 0, Math.PI*2);

      // Dark gray to black with transparency for sharp contrast on white
      const gradient = ctx.createRadialGradient(
        ix + p.jitterX, iy + p.jitterY, 0,
        ix + p.jitterX, iy + p.jitterY, DOT_SIZE * pulse * 3
      );
      gradient.addColorStop(0, 'rgba(30,30,30,0.9)');
      gradient.addColorStop(1, 'rgba(30,30,30,0)');
      ctx.fillStyle = gradient;
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 5;
      ctx.fill();
    }

    requestAnimationFrame(animate);
  }
})();
</script>

</body>
</html>
